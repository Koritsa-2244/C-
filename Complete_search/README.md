Полный перебор

Решить методом полного p-ичного перебора следующие задачи:
5.13. Гвозди и веревка
В доску в один ряд вбито N гвоздей (N<=20). Расстояния между соседними гвоздями 
- натуральные числа, записанные в текстовый файл по одному в каждой строке. 
Имеется веревка длины L. Веревку требуется разрезать на несколько частей так, чтобы 
каждой частью можно было связать какие-либо два соседних гвоздя и никакие два гвоздя не были связаны более одного раза. На привязывание веревки к гвоздю уходит Р единиц 
длины.
Описание программы:
Создаются переменные типа int р – количество единиц на привязывание гвоздей, l – длинна веревки, х – для чтения значений из файла, n = 0 – для подсчета количества элементов и массив m[20] – для запоминания расстояний.
Вводятся переменные длины веревки и количества единиц на гвозди, открываются файлы f1 – для чтения значений и f2 – для записи возможных комбинаций, если файл f1 пустой или отсутствует – выводим соответствующее сообщение.
Создается массив k типа bool и по циклу заполняется «0». В соответствии с данными этого массива будем проверять комбинации, если k[…] ==1 будем считать что гвозди связаны, если ==0 – что гвозди не связаны.
Цикл for по i от 0 до 2n – общего количества возможных комбинаций:
•	Объявляем переменную l1, присваиваем значение l – длины веревки, создаем переменную q (типа int) и присваиваем ей значение n-1, после чего в массив k добавляется – «1». (000 – 001; 101 – 110; и т.п.). 
•	Циклом for по j, от 0 до n, проходим по массиву k. Если значение k[j] = 1, от длины веревки l1 отнимаем 2*p (затраты на завязывание гвоздей) и отнимаем – m[j] расстояние между гвоздями.
•	Если после предыдущего цикла l1==0, значит комбинация подходит и её необходимо вывести, проходим циклом for по t, от 0 до n, по массиву k, выводим t+1, если k[t] == 1, выводим «-», иначе выводим пробел. 
